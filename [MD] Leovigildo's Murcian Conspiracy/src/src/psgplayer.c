// PSG multichannel sound effects player v1.0 por Shiru, 03.11.07
#include "genesis.h"
#include "main.h"

/* PSG multichannel sound effects player v1.0 by Shiru, 03.11.07 */

/* gcc version 12.12.07 */

/* Modified by @MoonWatcherMD 20130611. Thanks, Shiru! */

#define PSG_DATA		0xc00011
#define PSG_VCH_MAX	4


const u8 sfx_select_data[sfx_select_size] = {
	0x00,0x01,0x00,0x04,0x02,0x00,0x09,0x00,0x1d,0x00,0xc0,0x6a,0x80,0x54,0x80,0x50,
	0x80,0x23,0xd4,0x28,0x80,0x6a,0xe8,0x54,0x80,0x50,0xfc,0x00,0x00,0x01,0xfc,0x00,
	0xd4,0x6a,0x80,0x54,0x80,0x50,0x80,0x23,0xe8,0x28,0x80,0x6a,0xf4,0x54,0xf8,0x50,
	0xfc,0x00,0x00
};

const u8 sfx_confirm_data[sfx_confirm_size] = {
	0x00,0x01,0x00,0x04,0x02,0x00,0x09,0x00,0x25,0x00,0xc0,0xd5,0x02,0x80,0x8e,0x02,
	0xcc,0x47,0x02,0x80,0x6a,0x02,0xd4,0xd5,0x02,0x80,0x8e,0x02,0xdc,0x47,0x02,0xe8,
	0x6a,0x02,0xfc,0x00,0x00,0x01,0xfc,0x00,0x02,0xc0,0xd5,0x02,0x80,0x8e,0x02,0xcc,
	0x47,0x02,0x80,0x6a,0x02,0xd4,0xd5,0x02,0x80,0x8e,0x02,0xdc,0x47,0x02,0xe8,0x6a,
	0x02,0xfc,0x00,0x00
};

const u8 sfx_cancel_data[sfx_cancel_size] = {
	0x00,0x01,0x00,0x04,0x03,0x00,0x0b,0x00,0x21,0x00,0x39,0x00,0xc0,0x6b,0x80,0x48,
	0x80,0x24,0xd4,0x36,0x80,0x6b,0xdc,0x48,0xe4,0x24,0xec,0x36,0xfc,0x01,0x80,0x05,
	0x00,0x01,0xfc,0x01,0xc0,0x6b,0x80,0x48,0x80,0x24,0xd4,0x36,0x80,0x6b,0xdc,0x48,
	0xe4,0x24,0xec,0x36,0xfc,0x01,0x80,0x05,0x00,0x02,0xfc,0x01,0x80,0x05,0x01,0x80,
	0x01,0x83,0xff,0x83,0xfb,0x01,0x83,0xff,0x80,0x00,0x00
};

const u8 sfx_start_data[sfx_start_size] = {
	0x00,0x01,0x00,0x04,0x02,0x00,0x09,0x00,0x67,0x00,0xc0,0xfe,0x02,0x80,0xe2,0x02,
	0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,0x80,0x5f,0x02,0xc8,0xfe,0x02,0x80,
	0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,0x80,0x5f,0x02,0xd4,0xfe,
	0x02,0x80,0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,0x80,0x5f,0x02,
	0xdc,0xfe,0x02,0x80,0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,0x80,
	0x5f,0x02,0xe8,0xfe,0x02,0x80,0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,
	0x02,0x80,0x5f,0x02,0xfc,0x00,0x00,0x01,0xfc,0x00,0x02,0xc0,0xfe,0x02,0x80,0xe2,
	0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,0x80,0x5f,0x02,0xc8,0xfe,0x02,
	0x80,0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,0x80,0x5f,0x02,0xd4,
	0xfe,0x02,0x80,0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,0x80,0x5f,
	0x02,0xdc,0xfe,0x02,0x80,0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,0x6a,0x02,
	0x80,0x5f,0x02,0xe8,0xfe,0x02,0x80,0xe2,0x02,0x80,0x7f,0x02,0x80,0x71,0x02,0x80,
	0x6a,0x02,0x80,0x5f,0x02,0xfc,0x00,0x00
};

const u8 sfx_error_data[sfx_error_size] = {
	0x00,0x01,0x00,0x04,0x03,0x00,0x0b,0x00,0x41,0x00,0x77,0x00,0xc0,0xd5,0x80,0xe3,
	0x80,0xd5,0x01,0x80,0xe3,0x80,0xd5,0x80,0xc7,0x80,0xd5,0x80,0xe3,0x80,0xd5,0x80,
	0xc7,0x80,0xd5,0x80,0xe3,0x80,0xd5,0x80,0xc7,0xc4,0xd5,0x80,0xe3,0x80,0xd5,0x43,
	0x80,0xe3,0x80,0xd5,0xfc,0x00,0x80,0x0e,0x80,0x00,0x83,0xf2,0x80,0x00,0x80,0x0e,
	0x00,0x01,0xc0,0xd5,0x80,0xe3,0x80,0xd5,0x01,0x80,0xe3,0x80,0xd5,0x80,0xc7,0x80,
	0xd5,0x80,0xe3,0x80,0xd5,0x80,0xc7,0x80,0xd5,0x80,0xe3,0x80,0xd5,0x80,0xc7,0xc4,
	0xd5,0x80,0xe3,0x80,0xd5,0x43,0x80,0xe3,0x80,0xd5,0xfc,0x00,0x80,0x0e,0x80,0x00,
	0x83,0xf2,0x80,0x00,0x80,0x0e,0x00,0x02,0xfc,0x00,0x80,0x0e,0x80,0x00,0x83,0xf2,
	0x80,0x00,0x80,0x0e,0x80,0x00,0x83,0xf2,0x80,0x00,0x80,0x0e,0x80,0x00,0x83,0xf2,
	0x80,0x00,0x00
};

/*
PARA AGREGAR EFECTOS DE SONIDO
------------------------------

1.- Colocar los archivos de Mod2PSG2 convertidos a VGM al directorio "psgfx" (C:\GQ-Player\GQ-Player\psgfx)
2.- Editar vgmpsgfx.bat (C:\GQ-Player\GQ-Player\vgmpsgfx.bat) y añadir líneas con el nombre del nuevo archivo
3.- Agregar líneas como estas de INCLUDES con el nombre del nuevo archivo
4.- Añadir a "_list" los datos el nuevo efecto de sonido
*/

static const PSG _list [] =
{
	{ "confirm",      (u8*) sfx_confirm_data,    0 },
	{ "select",       (u8*) sfx_select_data,     0 },
	{ "cancel",       (u8*) sfx_cancel_data,     0 },
	{ "start",        (u8*) sfx_start_data,      0 },
	{ "error",        (u8*) sfx_error_data,      0 },

               // <-- Añadir líneas como las de arriba.
               //     Primero título, luego el nombre del VGM, y luego
               //     el patrón, que para nosotros siempre será 0


	{ "EOF",                 NULL,         0 } // no quitar!
};


static struct
{
	const u8 *data;

	struct
	{
		struct
		{
			s16 ptr;
			s16 wait;
			s16 time;
			u16 div;
			u8 vol;
		}
		slot[PSG_VCH_MAX];
	}
	chn[4];
}
PSGFX;


///////////////////////////////////////////////////////////////////////////////////////////////////


static void _psgfx_addch ( u16 chn,u16 off );





///////////////////////////////////////////////////////////////////////////////////////////////////


static void _psgfx_addch ( u16 chn, u16 off )
{
	s16 i, j, vchn, ntime, tmax, vcnt;

	if(chn<2)
	{
		tmax=PSG_VCH_MAX;

		for(i=2;i>=0;i--)
		{
			vcnt=0;

			for(j=0;j<PSG_VCH_MAX;j++)
			{
				if(PSGFX.chn[i].slot[j].ptr>=0)
				{
					vcnt++;
				}
			}

			if(vcnt==0)
			{
				chn=i;
				break;
			}
			if(vcnt<tmax)
			{
				tmax=vcnt;
				chn=i;
			}
		}
	}

	vchn=-1;

	for(i=0;i<PSG_VCH_MAX;i++)
	{
		if(PSGFX.chn[chn].slot[i].ptr<0)
		{
			vchn=i;
			break;
		}
	}

	if(vchn<0)
	{
		tmax=-1;

		for(i=0;i<PSG_VCH_MAX;i++)
		{
			ntime=PSGFX.chn[chn].slot[i].time;

			if(ntime>tmax)
			{
				tmax=ntime;
				vchn=i;
			}
		}
	}

	PSGFX.chn[chn].slot[vchn].ptr=off;
	PSGFX.chn[chn].slot[vchn].wait=0;
	PSGFX.chn[chn].slot[vchn].time=0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////




void psgFxPlay( u16 psg )
{
	volatile u8 *pb;

	s16 chn, eoff, doff, chcnt;
	u16 i, j;


	pb = (u8*) PSG_DATA;

	*pb = 0x9f;
	*pb = 0xbf;
	*pb = 0xdf;
	*pb = 0xff;

	PSGFX.data = (u8*) _list[psg].data;

	for(i=0;i<4;i++)
	{
		for(j=0;j<PSG_VCH_MAX;j++)
		{
			PSGFX.chn[i].slot[j].ptr=-1;
			PSGFX.chn[i].slot[j].wait=0;
		}
	}


	eoff  = 2 + ( _list[psg].num << 1 );
	doff  = ( PSGFX.data [ eoff ] << 8 ) + PSGFX.data [ eoff + 1 ];
	chcnt = PSGFX.data [ doff++ ];

	for ( i = 0; i < chcnt; i++ )
	{
		eoff=(PSGFX.data[doff++]<<8);
		eoff+=PSGFX.data[doff++];
		chn=PSGFX.data[eoff++];
		_psgfx_addch(chn,eoff);
	}
}


void psgFxFrame ( void )
{
	volatile u8 *pb;
	u8 mbyte;
	s16 pchn, vchn, rchn, mvol, nvol;
	u16 div;

	if ( !PSGFX.data )
	{
		return;
	}

	pb=(u8*) PSG_DATA;

	for ( pchn=0; pchn<4; pchn++ )
	{
		for(vchn=0;vchn<PSG_VCH_MAX;vchn++)
		{
			if(PSGFX.chn[pchn].slot[vchn].ptr<0)
			{
				continue;
			}

			PSGFX.chn[pchn].slot[vchn].time++;

			if(PSGFX.chn[pchn].slot[vchn].wait)
			{
				PSGFX.chn[pchn].slot[vchn].wait--;
				continue;
			}

			mbyte=PSGFX.data[PSGFX.chn[pchn].slot[vchn].ptr++];

			switch(mbyte&0xc0)
			{
				case 0x00:/*0=eof 1..31=wait*/
					if(!mbyte) PSGFX.chn[pchn].slot[vchn].ptr=-1; else PSGFX.chn[pchn].slot[vchn].wait=mbyte-1;
					break;
				case 0x40:/*vol only*/
					PSGFX.chn[pchn].slot[vchn].vol=mbyte&0x0f;
					break;
				case 0x80:/*div only*/
					PSGFX.chn[pchn].slot[vchn].div=((u16)mbyte<<8)|PSGFX.data[PSGFX.chn[pchn].slot[vchn].ptr++];
					break;
				case 0xc0:/*vol and div*/
					PSGFX.chn[pchn].slot[vchn].vol=(mbyte>>2)&0x0f;
					PSGFX.chn[pchn].slot[vchn].div=((u16)(mbyte&0x03)<<8)|PSGFX.data[PSGFX.chn[pchn].slot[vchn].ptr++];
					break;
			}
		}

		rchn=-1;
		mvol=16;

		for ( vchn = 0; vchn < PSG_VCH_MAX; vchn++ )
		{
			if ( PSGFX.chn[pchn].slot[vchn].ptr < 0 )
			{
				continue;
			}

			nvol=PSGFX.chn[pchn].slot[vchn].vol;

			if(nvol<mvol)
			{
				mvol=nvol;
				rchn=vchn;
			}
		}

		if(rchn>=0)
		{
			vchn=rchn;
			rchn=pchn<<5;
			*pb=0x80|0x10|rchn|PSGFX.chn[pchn].slot[vchn].vol;
			div=PSGFX.chn[pchn].slot[vchn].div;
			*pb=0x80|rchn|(div&0x0f);
			*pb=div>>4;
		}
	}
}


u16 psgfx_nb_tracks ()
{
	u16 i = 0;

	while ( _list[i++].data );

	return i - 1;
}


PSG *psgfx_get_track ( u16 num )
{
	return (PSG*) &_list[num];
}
